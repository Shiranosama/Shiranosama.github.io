<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「C++笔记」const限定符</title>
    <url>/posts/877242c6/index.html</url>
    <content><![CDATA[const限定符const
const限定符用于定义常量：
常量：一旦创建后其值就不可改变
const对象必须初始化

  const int var = 42;    //定义一个名为var的int常量


作用域
默认情况下，const对象被设定为仅在文件内生效
若需要const对象能被其他文件访问，须在声明或定义时添加extern关键字  //A.ccextern const int var = 42;    //在A.cc中定义var//B.ccextern const int var;    //在B.cc中声明var


const与引用
对const的引用（C++程序员常通俗称作常量引用）：
常量引用引用的对象可以是非常量对象，其不可用作修改所引用的对象，引用非常量对象时可通过其他途径修改所指对象的值
引用常量对象只能使用常量引用  const int var = 42;const int &amp;rf = var;
常量引用初始化时可以绑定任意表达式，只要其结果可以转换为引用类型，这会为此常量引用绑定临时量  // Your codedouble var = 1.61;const int &amp;rf = var;// 概念上，编译器会这样解释double var = 1.61;const int temp = var;    //将var转换为临时int常量const int &amp;rf = temp;    //让rf绑定临时量




常量引用实际并不存在，引用并非一个对象，无法使其本身保持不变，这仅是C++程序员约定俗成的称呼


const与指针
指向常量的指针：
指向常量的指针可以指向非常量对象，其不可用于修改所指向的对象，指向非常量对象时可通过其他途径修改所指对象的值
指向常量对象只能使用指向常量的指针  const int var = 42;const int *ptr = &amp;var;


常量指针
指针作为一个对象，可以将其本身定义为一个常量，这会使其存放的地址无法改变，而非指向的值，常量指针必须初始化  int var = 42;int *const ptr = &amp;var;




理解声明符：从右向左读，以int *const ptr = &amp;var;为例：将var的地址赋予名为ptr的对象(ptr &#x3D; &amp;var) –&gt; ptr是常量对象(const ptr)  –&gt; 常量对象ptr是一个指针(*const ptr) –&gt; 常量指针ptr指向int对象(int *const ptr) –&gt; ptr是一个指向int对象var的常量指针


const层级
顶层const表示对象是常量，底层const与复合类型的基本类型部分有关，表示绑定的对象是常量：  int var = 0;int *const ptr = &amp;var;    //顶层const，ptr的值不可修改const int cvar = 42;    //顶层const，var的值不可修改const int *ptr1 = &amp;var;    //底层const，ptr的值可以修改const int &amp;r = cvar;    //底层const，r引用的对象可变更const int *const ptr2 = ptr1;/* 靠右的const是顶层const，它使ptr2的值不可改变，另一个是底层const*/
const层级与拷贝赋值：
拷贝操作不会修改对象的值，因此顶层const无明显影响：

  var = cvar;    //Validptr1 = ptr2;    //Valid

但底层const限制必须拷入和拷出的对象具有相同层级的const，或者可以转换：

  	int *p = ptr2;    //Invalid，ptr3有底层const，p没有	ptr1 = ptr2;    //Valid，都有底层const	ptr1 = &amp;var;    //Valid，var的地址int*可以转换为const int*	int &amp;r = cvar;    //Invalid，cvar有底层const，r没有	const int &amp;r2 = var    //Valid，const int&amp;可以绑定int，满足转换条件* * *## 常量表达式- **常量表达式**是指值不会改变且在**编译时**就可以得到值的表达式，由它的数据类型和初始值决定	```C++	const int A = 42;   //A为常量表达式	const int B = A + 1;    //B为常量表达式	int C = 9;    //C不是常量，不是常量表达式	const int size = get_size(); // 除非get_size()是constexpr函数，否则这不是常量表达式
constexpr类型
将变量声明为constexpr类型以告诉编译器验证变量是否为常量表达式，声明的变量一定是常量，且必须使用常量表达式初始化；普通函数不可以作为constexpr变量的初始值，必须为constexpr函数（在编译时就能获得其值）
constexpr隐含顶层const
constexpr定义时用到的类型必须为字面值类型——简单、值显而易见的类型（算数类型、指针、引用等）

  constexpr int A = 20;    //Validconstexpr int B = A + 1;    //Validconstexpr int size = getSize();    //只有getSize是constexpr函数式此语句才正确

当你笃定一个变量是常量表达式时，就应该把它声明为constexpr类型


constexpr与指针：
在constexpr声明中定义一个指针，constexpr只对指针生效，与其所指向的对象无关；它也可以指向非常量
constexpr指针初始化时必须绑定具有固定地址的对象或为空指针





易错
指向常量的指针和对const的引用“自以为”它们绑定了一个常量（即使是非常量），因此无法通过它们改变所绑定对象的值，但可以通过其他方式改变
指向常量的指针VS常量指针


指向常量的指针
常量指针
特性



不可以
可以
是否可以通过它修改所指向的非常量的值


可以
不可以
是否可以修改其所指向的地址


可以
不可以
是否可以指向常量


底层const
顶层const
const层级



两者结合既不可以通过它修改所指向的非常量的值，又不可以修改其所指向的地址，但可以指向常量（右到左读法理解&#x3D;&gt;指向常量的常量指针）
constexpr声明中定义的指针为常量指针



]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>「C++笔记」处理类型：别名与auto与decltype</title>
    <url>/posts/ab2e220d/index.html</url>
    <content><![CDATA[类型别名
类型别名是一个等价于某种类型的名字
定义方式有传统的typedef和别名声明（using） 两种
定义的别名等价于对应类型（包括复合类型）

  typedef double dub;    //dub是double的别名using unint = unsigned int;    //unint是unsigned int的别名using pdub = double*;    //pdub是double*别名pdub ptr = nullptr;    //等价于double* ptr = nullptr;


auto类型说明符
auto会告诉编译器去分析表达式所属类型并赋予变量
用于定义时必须有初始值
声明多个变量时初始基本数据类型必须一致
auto通常会忽略顶层const，保留底层const

  auto var = 42, *pvar = &amp;var;const int i = 42;auto a = i;    //a是一个整数const auto b = i;    //b为int常量//对常量获取地址是一种底层constauto c = &amp;i;    //c是一个指向int常量的指针


decltype类型指示符
decltype用于选择并返回操作数的数据类型
编译器会分析表达式并返回它的类型，但不计算实际的值
如果表达式能做为左值，则返回引用类型
变量的类型会如实返回（包括引用和顶层const）
给变量名加上括号会让其被识别为表达式，这会返回引用类型





  decltype (ft()) var = x;    //var的类型为函数ft()的返回值const int a = 42, &amp;r = a;decltype (a) b = a;    //b的类型为const intdecltype (r) c = b;    //c的类型为const int&amp;


易错
using pint = int*的含义是pint是int*类型的别名，在使用它进行声明时const pint ptr = nullptr的含义是一个指向int类型的常量指针，而非const int *ptr = nullptr的一个指向int常量的指针

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>「折腾日记」Linux发行版的介绍与选择——Linux，计算机不得不品的一环Part1</title>
    <url>/posts/aaa88a44/index.html</url>
    <content><![CDATA[前言岚的声明本文为岚的折腾日记，它只是因为我想而写下的，不具备权威性，我也无法保证正确，仅供参考
参考资料
英文wikipedia
对应发行版Wiki

Linux是什么提到计算机，你第一时间想到的是什么？是电影里酷炫的输出流，还是五花八门的编程语言？它们都是计算机的一部分，但计算机的本质，却是操作系统。操作系统是计算机硬件和软件之间的桥梁，它负责管理计算机的资源，翻译用户的输入，并输出结果。而Linux，就是众多操作系统中的一个。Linux内核起源于芬兰人Linus Benedict Torvalds之手，也就是我们常说的Linux之父，他在1991年发布了Linux内核的第一个版本 （没错，严格来说Linux实际上指操作系统内核），而 完整的操作系统包含 Linux内核 GNU工具链 以及 X Window等其他组件。GNU起源于Richard Matthew Stallman发起的GNU计划，目标是创建一个完全自由的操作系统。自由软件基金会将 GNU工具链与Linux内核的组合命名为 GNU&#x2F;Linux，但由于Linux不属于GNU 计划的一部分，因此GNU&#x2F;Linux这一命名也没有获得社区的一致认可。不过，现在人们通常将Linux直接用于指代完整操作系统。本文将遵循大多数人的习惯，使用Linux一词来指代基于Linux内核的完整操作系统（即Linux发行版）。
小知识：GNU 计划中的“GNU”是 “GNU’s Not Unix!” 的缩写，意为 “GNU不是Unix”；开源协议 GPL——GNU General Public License 也来自这里，意为 “GNU通用公共许可证”。

得益于 Linux 开源的特性，其得到了广泛的传播和应用。从桌面操作系统到服务器操作系统，从嵌入式系统到移动设备，Linux 都在其中发挥着重要作用。例如你手头的安卓手机，就是基于 Linux 内核的操作系统。而它的另一个重要应用领域是服务器，如 RHEL、CentOS。许多大型网站和互联网公司都使用 Linux 作为其服务器操作系统，因为它的稳定性和安全性都得到了广泛的认可。对于个人用户，也诞生了许多 Linux 发行版，如 Ubuntu、Fedora、Debian 等，它们提供了丰富的实用工具和易于使用的界面，使得 Linux 操作系统更加易于使用。
Why Linux?
自由：Linux 是开源的，你可以在GPL许可范围内自由地修改和分发它。这意味着你可以随心定制 Linux，而不必担心受到供应商的限制。
稳定：Linux以其 稳定性 和 可靠性 而闻名。它被广泛应用于服务器和嵌入式系统。
性能：得益于开源的特性，Linux 社区百花齐放，各种优化和改进层出不穷，也没有像Windwos那样为了兼容而累积的“遗留代码”，加上其可用多种高性能文件系统(btrfs、ext4、XFS等)，使得 Linux 在性能上有着不俗的表现。

一些注意事项
Linux在 开发、服务器、桌面、日常工作等 用途都有不错的表现，但其 并不适用Windows生态，在Linux下运行Windows软件要额外的 兼容层，如 Wine，但并不能保证能正常运行，且 性能大打折扣。
Linux即便有 Wine，也并 不推荐作为Windows软件开发环境，Windows仍是 开发Windows软件的首选，而Linux下需要 交叉编译环境。给开发者的小建议：Windows+WSL或者Windows&#x2F;Linux双系统，是不错的选择。

Linux需要一定的耐心，在不断试错的过程中DIY你自己的Linux系统。
Linux的社区资源丰富，遇到问题可以尝试搜索，或者加入社区，寻求帮助。
使用Linux，就不能怕麻烦，虽然Linux的安装过程日渐趋于简单，但接下来的使用、维护、升级等，都需要用户具备一定的技术知识。如果你对Linux感兴趣，那么本文（指南第一部分）将带你了解Linux发行版，以及如何选择适合自己的Linux发行版。

Linux发行版目前Linux发行版主要分为三大分支以及一些自成一派的发行版，下图展示了Linux发行版家族的分类以及部分代表发行版，* 指通常没有官方提供的交互式安装程序：

    flowchart LR
  A[Debian系&lt;br &#x2F;&gt;易于上手且稳定]
  B[Arch系&lt;br &#x2F;&gt;丰富的社区生态：AUR、ArchLinuxCN，高度定制化]
  C[RedHat系&lt;br &#x2F;&gt;企业级，稳定，服务器]
  A --&gt; D[Debian]
  A --&gt; E[Ubuntu]
  A --&gt; H[Deepin]
  A --&gt; I[Kali Linux]
  B --&gt; J[Arch Linux **\***]
  B --&gt; K[Manjaro]
  B --&gt; L[BlackArch]
  C --&gt; M[RHEL]
  C --&gt; N[CentOS]
  C --&gt; O[Fedora]
  P[Other]
  P --&gt; Q[Gentoo **\***]
  P --&gt; R[NixOS **\***]
  P --&gt; S[Slackware]
  

Debian系经典的发行版，以稳定性著称，适合初学者和需要稳定性的用户。Debian是Linux发行版的鼻祖，拥有较长的历史和最广泛的社区支持。Debian的稳定版本通常被认为是最可靠的，适合个人和商业使用；Debian还提供了大量的文档和教程，帮助用户学习和使用Debian。Ubuntu和Deepin都是基于Debian的发行版，它们提供了更开箱即用的体验和更多的特性，是入门Linux的好选择。

包管理：APT （Advanced Package Tool）
包格式：.deb

RedHat系红帽致力于服务器级操作系统与相关付费服务，其主推系统为RHEL（Red Hat Enterprise Linux），商业订阅制服务器操作系统；CentOS是基于RHEL开源代码编译的发行版；Fedora是红帽提供支持的发行版，用于测试RHEL可能的新功能，稳定性低于RHEL&#x2F;CentOS，但更适合桌面用户。RedHat系发行版通常具有强大的企业级支持，稳定性和安全性都得到了广泛的认可。包管理：YUM （Yellowdog Updater, Modified）&#x2F;DNF （Dandified YUM）包格式：.rpm
CentOS Linux已在2024年6月30日停止维护，项目重心转到了CentOS Stream(滚动发布)，也是RHEL上游测试版。


Arch系Arch是三大分支中最灵活的发行版，它的主旨是：极简主义、完全的用户控制；其最大的特点是社区生态，社区维护者为其带来的其他发行版没有的庞大的软件包仓库，如AUR（Arch User Repository）、ArchLinuxCN等。Arch的安装过程相对复杂，需要用户具备一定的技术知识，但一旦安装完成，Arch的灵活性和定制性将使你体验到前所未有的自由，也是我个人选择最适合日用的发行版。Manjaro是基于Arch的发行版，它专注于用户友好性和开箱即用的体验，是入门Arch的好选择。但作为Arch教徒，我还是推荐直接使用Arch

包管理：
Pacman 官方仓库
paru/yay AUR（Arch User Repository）


包格式：.pkg.tar.zst/.pkg.tar.xz
建议：常备LiveCD

其他
Gentoo是深度自定义的发行版，适合极客用户，学习成本高。其特点是，用户可以根据自己的需求控制内核、软件包的编译，以达到极致的性能优化和系统适配；虽然Gentoo提供了二进制包，但Gentoo用户会选择自行编译内核与所有软件包来达到性能优化，即使这可能花上几天时间；Gentoo安装过程复杂，需要用户具备一定技术知识 以及一块强大的CPU。
包管理：Portage （Gentoo Portage）




NixOS是基于Nix包管理器和构建系统的发行版，适合极客用户，学习成本高。在NixOS中，发行版的所有组件——包括内核、安装包和系统配置文件——都是由Nix从称为Nix表达式的纯函数构建的，用户可以用配置文件配置整个系统，甚至用同样的配置文件复现它，但这也意味着安装过程复杂，需要用户具备一定技术知识。
包管理：Nix （Nix包管理器）




Slackware: 现存最古老的发行版之一，坚持 UNIX哲学和KISS原则，在一众发行版中显得特立独行，设计简洁、稳定。其包管理相对简易，更依赖传统方式（如源码编译）。面向需要深度理解系统底层、偏好高度定制的高阶用户。

补充目前Linux发行版分为滚动发布和固定版本发布两种：

滚动发布的系统会持续收到新的软件包和内核更新，没有固定的版本号，如Arch、Gentoo、Debian sid等，它可以保证系统在理论上始终处于最新状态，但这也意味着系统可能不稳定，流行的滚动发行版通常会极力降低此风险，也诞生了像Btrfs&#x2F;ZFS这样支持快照回滚的文件系统，但滚动发布的系统作为生产环境仍需考量。
固定版本发布的系统会有固定的版本号，如Ubuntu 25.04、Fedora 42、Deepin 25等，它们会定期发布经过测试的稳定版本，这些版本用户主要通过包管理器获取补丁和软件更新，而主要的软件包和内核更新需要升级到下一个版本才能获得，固定版本发布的系统通常在支持时限内更稳定，但可能不会获得最新的软件包和内核更新。

本文提到的Linux发行版并非全部，开源社区很大，还有许多其他发行版，如openSUSE、Mint、Zorin OS等，它们各有特色，适合不同用户的需求，多逛逛或许能碰上你心仪的发行版。
如何选择适合自己的Linux发行版
    flowchart LR
  A[Debian系]
  B[RedHat系]
  C[Arch系]
  D[其他]
  E[如何选择]
  E --&gt;|初学者和&lt;br &#x2F;&gt;需要稳定性的用户| A
  E --&gt;|有一定&lt;br &#x2F;&gt;Linux基础的用户| C
  E --&gt;|企业级，稳定服务器&lt;br &#x2F;&gt;或喜欢Fedora的&lt;br &#x2F;&gt;桌面体验| B
  E --&gt;|深度自定义&lt;br &#x2F;&gt;享受折腾| D
  A --&gt;|大道至简&lt;br &#x2F;&gt;我要自己动手| Debian
  A --&gt;|简单易用&lt;br &#x2F;&gt;我要开箱即用| Ubuntu
  A --&gt;|支持国产&lt;br &#x2F;&gt;优秀本地化| Deepin
  B --&gt;|企业级&lt;br &#x2F;&gt;完善服务| RHEL
  B --&gt;|企业级&lt;br &#x2F;&gt;免费| CentOS
  B --&gt;|测试功能&lt;br &#x2F;&gt;优秀桌面体验| Fedora
  C --&gt;|大道至简&lt;br &#x2F;&gt;我要自己动手| Arch
  C --&gt;|简单易用&lt;br &#x2F;&gt;我要开箱即用| Manjaro
  D --&gt;|自定义&lt;br &#x2F;&gt;享受折腾| Gentoo
  D --&gt;|声明式配置&lt;br &#x2F;&gt;可靠系统| NixOS
  D --&gt;|UNIX风格&lt;br &#x2F;&gt;极客| Slackware
  

结语以上，本章完。
下一篇：「折腾日记」Linux的基本安装与配置
]]></content>
      <categories>
        <category>折腾日记</category>
        <category>Linux传教</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>「折腾日记」Linux基本安装与配置——Linux，计算机不得不品的一环Part2</title>
    <url>/posts/312fd4e3/index.html</url>
    <content><![CDATA[前言岚的声明本文为岚的折腾日记，它只是因为我想而写下的，不具备权威性，我也无法保证正确，仅供参考
在上一篇文章中，我们介绍了Linux的起源、发展以及如何选择适合自己的发行版。本文将介绍Linux的基本安装与配置，帮助读者更好地了解和使用Linux系统本文并不会去介绍某一发行版的安装，官方文档已经足够详细，我将会介绍安装通用步骤都做了什么，并引出一些基本概念
与前文相同，本文将Linux用于指代基于Linux内核的操作系统
参考资料
英文WikiPedia
ArchWiki
GentooWiki
个人经验

安装准备
工具：U盘（虚拟机无需）、Linux发行版映像、Rufus&#x2F;Etcher、充足的磁盘空间、以及一双手


刻录LiveCD：使用Rufus或Etcher将Linux发行版映像刻录到U盘上
重启计算机，进入BIOS&#x2F;UEFI设置，启动LiveCD
使用手机或其他设备打开对应发行版的官方文档，通常会提供详细的安装指南和常见问题解答

LiveCD是一个完整的可引导安装程序（类似WinPE），它包含一个完整的操作系统，允许用户从储存设备将操作系统载入到内存运行，而非从硬盘驱动器载入。LiveCD通常用于演示操作系统、系统安装、修复系统故障等场景


分区
分区前请备份重要数据，分区操作不可逆

分区工具：

一般而言，Linux发行版提供的安装映像会自带分区工具，eg.cfdisk(交互式)、fdisk(命令行)、parted(交互式)、gparted(图形化) 等；有关工具如何使用，这里不做介绍
替代方案：使用WinPE进行分区再后进入LiveCD进行安装


分区方案：

通常，UEFI设备建议使用GPT分区表，建议分区方案为：
根分区：推荐格式：ext4；根分区，建议大小为16GB以上，用于存放/目录下的文件
EFI分区：推荐格式：fat32；EFI启动分区，建议大小为300MB，用于存放EFI启动文件，其会挂载到根分区的/boot/efi目录
/home：推荐格式：ext4；用户主目录，用于存放/home目录下的文件，需要将其挂载到根分区的/home目录
交换分区：推荐格式：swap；交换分区，用于在物理内存不足时提供额外的内存空间，建议大小为物理内存的1.5倍


Legacy BIOS设备建议使用MBR分区表，建议分区方案为：
根分区：推荐格式：ext4；根分区，建议大小为16GB以上，用于存放/目录下的文件
BIOS分区：推荐格式：xfs；BIOS启动分区，建议大小为300MB，用于存放BIOS启动文件，其会挂载到根分区的/boot目录
/home：推荐格式：ext4；用户主目录，用于存放/home目录下的文件，需要将其挂载到根分区的/home目录
交换分区：推荐格式：swap；交换分区，用于在物理内存不足时提供额外的内存空间，建议大小为物理内存的1.5倍




Legacy BIOS设备分区方案与UEFI引导设备分区方案类似，区别在于分区表格式和Boot分区不同


Linux分区方案较为灵活，例如/home可以合并到根分区中，或者增加/tmp、/var等分区用于存放临时文件和变量文件，独立分区可以增强安全性，便于备份和维护；也可以不使用交换分区，在稍后配置swap文件或ZRAM；EFI分区使用fat32格式可以与Windows系统共用

挂载分区：

使用对应命令将分区挂载到对应目录，例如：# 挂载根分区到/mntmount /dev/sda1 /mnt# 挂载启动分区到/mnt/boot/efimount /dev/sda2 /mnt/boot/efi# 挂载用户主目录到/mnt/homemount /dev/sda3 /mnt/home# 挂载交换分区到/mnt/swapmount /dev/sda4 /mnt/swap
使用lsblk命令查看分区情况，确保分区挂载正确


磁盘与分区：

磁盘通常指存储设备，分区操作是使用分区表将磁盘划分为多个逻辑分区，用户可以为每个分区指定文件系统和挂载点，以便在操作系统中进行访问和管理



其他文件系统eg.btrfs、xfs、zfs等也可以根据个人需求进行选择，不同文件系统具有不同的特性，例如btrfs具有快照、压缩、RAID、子卷等功能；特性不同的文件系统最优分区方案也不同，如btrfs通常是根分区配合子卷


网络
确保网络连接正常，可以使用ping bing.com命令测试网络连接
连接网络：
多数安装映像会自动连接有线网络，无线网络需要手动连接；若未提供交互式网络连接工具，可以使用iw或nmcli等工具进行连接


更新时间以确保Live环境时间准确：
使用timedatectl命令更新时间

有关网卡驱动问题：如果遇到在LiveCD中无法连接网络，可以尝试使用官方提供的离线安装映像，或者使用有线网络进行安装


安装
配置镜像源：
国内用户通常难以连接官方镜像，可以使用国内镜像源进行安装，eg. 校园网联合镜像站，按照对应文档进行配置
配置完成后，便可以开始安装；交互式安装工具会自动从配置的镜像源下载并安装软件包


更新缓存：
使用对应包管理命令更新软件包缓存


安装软件包，除必须软件包外，其他可稍后安装：
base：基础软件包，包括系统核心、基本工具、库等 必须
base-devel：开发软件包，包括编译器、构建工具、库等 必须
linux：内核软件包，包括内核、模块等 必须
linux-firmware：内核固件软件包，包括内核固件等 必须
grub：引导程序软件包，包括引导程序等 必须
efibootmgr：EFI引导管理器软件包，用于管理EFI引导项
sudo：权限管理软件包，用于管理用户权限
networkmanager：网络管理器软件包，用于管理网络连接
ALSA：音频系统软件包，用于管理音频设备
pulseaudio：音频服务器软件包，用于管理音频流
vim：文本编辑器软件包，用于编辑文本文件
其他软件包，根据需要的软件包进行安装，eg.gnome、plasma、firefox等


包管理：
包管理(Package Management)是用于统一管理软件包的工具，它旨在自动处理软件包的安装、更新、卸载等操作，并解决软件包之间的依赖关系；通常包管理会从 储存库(Repository) 中下载软件包及其元数据（版本号、校验信息、依赖关系等），然后自动处理软件包的安装、更新、卸载等操作

Linux软件包小科普：Linux软件包通常具有庞大的依赖关系，例如安装A软件包需要B软件包，安装B软件包需要C软件包，幸运的是，现在大多数包管理会自动解决依赖关系，无需手动安装依赖包


交互式安装结束
从此开始，多数交互式安装程序会自动完成安装并进入系统，无需手动干预

Chrooting
安装了基本软件包后，此时Linux系统已经可以运行，但是由于还没有配置引导程序，所以无法从硬盘启动；此时通过LiveCD进入Chroot环境，进一步配置系统

记得先复制DNS信息：
cp --dereference /etc/resolv.conf /mnt/etc/
进入Chroot环境的方法请参照官方文档，一些发行版提供快捷设置Chroot环境的脚本，如arch-chroot；这里着重介绍手动设置Chroot环境的方法：

挂载必须的文件系统：


&#x2F;proc&#x2F;，伪文件系统，由内核提供，用于提供进程信息、内核参数等
&#x2F;sys&#x2F;，伪文件系统，类似 &#x2F;proc&#x2F;，但更结构化
&#x2F;dev&#x2F;，设备文件系统，用于提供设备文件
&#x2F;run&#x2F;，临时文件系统，用于运行时数据，如PID文件、锁文件等

  mount -t proc none /mnt/procmount --rbind /sys /mnt/sysmount --make-rslave /mnt/sysmount --rbind /dev /mnt/devmount --make-rslave /mnt/devmount --bind /run /mnt/runmount --make-slave /mnt/run

–make-rslave：将挂载点设置为从属挂载点，用于安装systemd时避免挂载点被破坏


修改根目录：

  chroot /mnt /bin/bash

设置环境变量：

  source /etc/profileexport PS1=&quot;(chroot) $&#123;PS1&#125;&quot;

Fstab
fstab文件通常列出所有可用的磁盘分区和其他类型的文件系统以及可能不是基于磁盘的数据源，并告诉它们如何初始化或以其他方式集成到更大的文件系统结构中；一般而言，/etc/fstab文件中每行包含6个字段，分别是：
&lt;device&gt;：用于指明要挂载的设备或远程文件系统，可以是设备路径、UUID、分区标签
&lt;dir&gt;：用于指明挂载点，即 &lt;device&gt; 挂载到何处
&lt;type&gt;：用于指明文件系统类型，eg. ext4、vfat、swap等
&lt;options&gt;：用于指明mount命令的参数，用半角逗号分隔，如 defaults，noatime，nodiratime，不同文件系统支持的参数不同，请参考对应文件系统文档
&lt;dump&gt;：用于指明是否使用dump备份文件系统，0表示不备份，1表示备份
&lt;fsck&gt;：用于指明文件系统检查的顺序，0表示不检查，1表示优先检查，2表示次优先检查
示例：# &lt;device&gt;                                &lt;dir&gt; &lt;type&gt;          &lt;options&gt;                                        &lt;dump&gt; &lt;fsck&gt;UUID=0a3407de-014b-458b-b5c1-848e92a327a3 /     ext4 defaults,noatime,nodiratime                       0      1UUID=CBB6-24F2                            /boot vfat defaults,nodev,nosuid,noexec,fmask=0177,dmask=0077 0      2UUID=f9fe0b69-a280-415d-a03a-a32752370dee none  swap defaults                                           0      0UUID=b411dc99-f0a0-4c87-9e05-184977be8539 /home ext4 defaults,noatime,nodiratime                       0      2


交互式安装的发行版会自动配置fstab文件；其余发行版请参考官方文档或手动编辑fstab文件

配置
这一步会配置系统的一些基本设置，如时区、主机名、用户名、密码等，许多系统会提供交互式工具进行配置
时间：# 设置时区ln -sf /usr/share/zoneinfo/Region/City /etc/localtime# 同步时间hwclock --systohc

这会根据/etc/localtime文件中的时区设置系统时间，并同步到硬件时钟


本地化：# 设置本地化vim /etc/locale.gen #把你需要的语言取消注释，eg. en_US.UTF-8 UTF-8、zh_CN.UTF-8 UTF-8locale-genecho &quot;LANG=en_US.UTF-8&quot; &gt; /etc/locale.conf

这会根据/etc/locale.gen文件中的设置生成本地化文件，并设置系统默认本地化为en_US.UTF-8

不建议设置/etc/lacale.conf为任何非英文值，这会导致 TTY(终端) 显示乱码

键盘布局：echo &quot;KEYMAP=us&quot; &gt; /etc/vconsole.conf

这会设置系统默认键盘布局为us，即美式键盘布局；可以根据个人需求进行修改


主机名：echo &quot;hostname&quot; &gt; /etc/hostname

这会设置系统主机名为hostname；1~63个字符，只能包含a-z、0-9以及-，不能以-开头


Initramfs：
这一步会生成initramfs，不同系统生成initramfs的方法不同，请参考官方文档

initramfs是为了避免将大量驱动程序硬编码到内核导致内核过大、用于启动时推断根文件系统位置、以及实现休眠挂起等问题而诞生的；它是一个临时根文件系统，在系统启动时加载，用于加载内核模块、挂载根文件系统和查找设备等

User：
这一步会配置用户，包括创建用户、设置密码等；一定不要忘记设置Root密码和用户密码，否则无法进入系统

# 配置Root密码passwd root# 创建用户并加入wheel组useradd -m -G wheel 用户名# 设置用户密码passwd 用户名

配置sudo，确保你安装了sudo！！：

# 编辑sudoers文件vim /etc/sudoers# 取消注释以下行，不要使用%wheel ALL=(ALL) NOOPASSWD: ALL！！%wheel ALL=(ALL) ALL

这会配置sudo，允许wheel组中的用户使用sudo命令；一定不要使用「%wheel ALL&#x3D;(ALL) NOOPASSWD: ALL」，这会导致wheel组中的用户可以无密码使用sudo命令，存在安全风险

sudo(substitute user, do)不同于su，sudo允许用户以其他用户的身份执行命令，而不是完全切换到其他用户；这可以限制用户的权限，防止用户执行危险命令


引导程序
引导程序(bootloader) 是负责启动操作系统的软件；在计算机启动阶段，操作系统和加载程序并未在RAM中运行，此时计算机会执行引导ROM中的程序(eg.BIOS、UEFI)，该程序会初始化硬件，定位并加载引导程序，称为第一阶段引导；引导程序(eg.GRUB、rEFInd)加载操作系统并使操作系统初始化，称为第二阶段引导
引导程序通常安装在MBR&#x2F;ESP中，MBR是计算机启动时首先读取的512字节的扇区，ESP是EFI系统分区，用于存放EFI引导程序
这里主要讲讲广泛使用的**GRUB 2(以下简称GRUB)**的安装配置：
使用包管理器安装GRUB；UEFI系统需要额外安装efibootmgr；多系统需要安装os-prober
写入GRUB到MBR&#x2F;ESP，确保你的分区正确挂载！！：

  # 安装GRUB到MBRgrub-install --target=&quot;CPU架构与系统平台 eg. i386-pc&quot; &quot;Boot分区 eg. /dev/sda1&quot;# 安装GRUB到ESPgrub-install --target=&quot;CPU架构与系统平台 eg. x86_64-efi&quot; --efi-directory=&quot;ESP分区挂载点 eg. /boot/efi&quot; --bootloader-id=&quot;引导程序名称 eg. Arch&quot;

配置GRUB：

  # 编辑GRUB配置文件vim /etc/default/grub
  # GRUB配置文件示例GRUB_DEFAULT=0 # 默认启动项，0表示第一个启动项GRUB_TIMEOUT=5  # 启动等待时间，单位为秒，-1表示无限等待GRUB_CMDLINE_LINUX=&quot;quiet splash&quot; # 内核参数，quiet表示不输出内核信息，splash表示显示启动画面GRUB_DEVICE=&quot;设备 eg. /dev/sda&quot; # 系统设备，用于查找根文件系统GRUB_DISABLE_OS_PROBER=false # 是否禁用os-prober，false表示不禁用，true表示禁用
  # 生成GRUB配置文件grub-mkconfig -o &quot;grub安装点 eg. /boot/efi/grub/grub.cfg&quot;

此命令会根据 &#x2F;etc&#x2F;default&#x2F;grub文件中的配置生成GRUB配置文件，并保存到 grub安装点中


检查一下GRUB是否正确安装：

  # 查看GRUB安装点ls &quot;grub安装点 eg. /boot/efi/grub&quot;

第二阶段引导硬件已经初步初始化，因此可以实现图形化，这意味着你可以通过配置文件自定义引导程序的界面，如GRUB的主题、字体、背景等


重启
使用Ctrl+D组合键退出Chroot环境，使用reboot命令重启系统，进入BIOS&#x2F;UEFI界面，将引导程序设置为第一个启动位置，保存设置并重启系统，进入Linux系统
Linux安装完成后LiveCD也不要丢弃，它可以作为系统修复的环境，类似WinPE


]]></content>
      <categories>
        <category>折腾日记</category>
        <category>Linux传教</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>「折腾日记」从零开始的MPC-BE+MadVR+LAVFilters的播放器配置指南</title>
    <url>/posts/608b9288/index.html</url>
    <content><![CDATA[长文注意⚠️
前言岚的声明本文为岚的折腾日记，它只是因为我想而写下的，不具备权威性，我也无法保证正确，仅供参考
本文参考
万年冷冻库的播放器教程
维基百科
以及一些论坛

一些碎碎念Potplayer 被广泛推荐，但它因使用开源项目代码（如 FFmpeg）却闭源发布，被认为可能违反 GPL 协议，且部分版本包含推广内容，引起了一些争议，故本文不推荐开源的MPC-BE且功能同样强大，且积极维护当然MPC-BE并非唯一选择，也可以选择mpv，它更加强大，且跨平台，具体参见mpv_lazy本文主要介绍基于MPC-BE的配置，我并非音视频相关专业人士，主要提供一个参考，不会去深入讲解 (因为我也不会)，有需要请自行查阅相关资料
Video Helper是一个很实用的网站，多数音视频相关的软件都可以在这里找到甚至溯源
内容太多啦，脑袋晕晕的(っ °Д °;)っ，可能会有错误，欢迎指正
安装
MPC-BE —— 播放器本体
也可以选择K-Lite Codec Pack，这是一个 MPC-HC(非MPC-BE) 懒人整合包，包含MPC-HC、LAVFilters、madVR等
MadVR —— 视频渲染
下载后解压，运行install.bat即可
madshi目前对MadVR提供了Test Build，包含更专业的配置项目，尤其是HDR部分，普通用户可选性安装
madVRhdrMeasure(Test Build)版本过期时会在播放器提示更新，获取更新的方式为当前版本号+1，例如：http://madshi.net/madVRhdrMeasure208.zip ，过期后更新为 http://madshi.net/madVRhdrMeasure209.zip


LAVFilters —— 分离器&#x2F;解码器
xy-VSFilter —— 字幕渲染器
下载后解压，运行Install_XySubFilter.bat即可

配置前言：除了给出推荐配置外，还会尽可能告诉你每个配置项的含义，可能会有些啰唆(。・ω・。)
MPC-BE
右键-选项-视频

视频渲染器，选择MadVR


字幕

字幕，选择XySubFilter


滤镜

内置滤镜：把源滤镜、视频解码器、音频解码器下的所有滤镜取消勾选，以保证不使用播放器自带的解码器
拓展滤镜：添加滤镜，在弹出的窗口中选择LAV Splitter、LAV Splitter Source、LAV Video Decoder以及LAV Audio Decoder，并确保勾选
拓展滤镜：将LAV Video Decoder和LAV Audio Decoder的优先级改为“首选”



LAVFiltersLAV Video Configuration
建议配置如下：  
Settings：
Threads for Multi-Threading(多线程)，选择Auto即可
Use Stream Aspect Ratio(使用流宽高比)，选择 Indeterminate(Auto) 即可
Settings for Interlaced Video Streams(交错视频流设置)：
Field Ordering(场序)，选择Auto：注意Auto可能误判老式DVD，错误的场序会导致画面出现跳帧、画面撕裂等，如果遇到判断错误的情况可以尝试手动启用top-field-first(顶部优先)或bottom-field-first(底部优先)
Deinterlace Mode(反交错模式)选择Auto即可，如果遇到判断错误的情况可以尝试手动启用
选项解读：
Auto：使用帧标志(Field Flags)判断隔行&#x2F;逐行
Aggressive：强制处理所有疑似隔行扫描的帧(可能误判)
Force：无视帧标记，全部按隔行处理（老片源救星）
Disabled：将所有帧都按逐行扫描处理






右下角的Software Deinterlace，是软件反交错，显卡正常的情况下不建议启用
概念解读：
逐行扫描：将每一帧从左至右、由上至下，逐一的将所有的像素显示出来
隔行扫描：将一帧图像的奇数行像素及偶数行像素分开，分成为两个场域(field)。轮流扫描奇数行所构成的场及偶数行所构成的场域
现在新式的显示设备大多都是使用逐行扫描，在这些新型的显示设备上直接播放隔行信号会产生严重的闪烁现象，而且因隔行信号两行只有一行有影像另一行则是全黑的，所以亮度看起来会减少一半。由于有上述这些问题，所有使用逐行扫描的新式显示设备都需要有 反交错(Deinterlace) 的功能




Hardware Acceleration(硬件加速)：
Hardware Decoder to use，建议D3D11，旁边的Resolution和Codecs for HW Decoding全部勾选(启用所有支持的格式和分辨率)，Device to use选择你的高性能显卡


Output Format(输出格式)，全部勾选
其余选项默认即可
Format分页维持默认即可(通常不需要手动启用&#x2F;禁用特定格式)

LAV Audio Configuration
建议配置如下：    
Dynamic Range Compression(动态范围压缩)，可以动态调整音频输出幅值，避免音量忽大忽小&#x2F;破音，但会损失原声动态细节，一般保持关闭即可
Bitstream (S&#x2F;PDIF, HDMI)(比特流)：
注意：Bitstream(比特流)需音频设备原生支持解码（如功放显示”DTS-HD MA”），若不支持启用格式将导致无声
如果你是笔记本扬声器&#x2F;耳机，此项保证禁用，因为笔记本扬声器不支持Bitstream(比特流)输出
如果你有通过 HDMI 连接支持高级音频解码的 AV 功放 或 多声道音箱系统&#x2F;通过光纤&#x2F;同轴 (S&#x2F;PDIF) 连接支持基础解码的 Soundbar 或功放，可以根据具体设备的支持情况来选择。例如：直接连接电视时，通常需要确认电视支持的比特流格式（查看电视说明书或音频输出设置），或更简单地选择 PCM 输出让电视解码
配置解读：
Formats：这里列出了 LAV Audio 可以尝试进行Bitstream(比特流)输出的具体格式。你需要勾选你希望 LAV 尝试传递的格式
Force max DTS+ID rate (not recommended)：强制最大DTS码率，不建议使用
Fallback to PCM if Bitsreaming is not supported：如果Bitstream(比特流)输出不被支持，则回退到PCM输出，建议勾选


概念解读：
Bitstream(比特流)：将原始、未经解码的音频数据直接从播放器传递给你的外部音频设备(如声卡等)，这需要接收端设备具备相应的解码能力
PCM(脉冲编码调制)：播放器（LAV Audio）先将音频编码数据解码成原始的、未压缩的多声道 PCM 数据，再输出给音频设备。这是最通用的方式，所有设备都支持 PCM 输出




Optins：
Auto A&#x2F;V Sync correction(自动音视频同步校正)，自动音视频同步校正，勾选
Convert Output to Standard Channel Layouts(将输出转换为标准声道布局)，用于HDMI输出PCM时，声道未达到标准(5.1&#x2F;6.1&#x2F;7.1)时自动添加静音声道补齐，一般有下游混音器(例如Win自带的WASAPI)则不需要勾选，如果下游设备严格要求标准布局（某些老旧设备），则需要勾选，对于大多数现代设备（通过 HDMI 连接功放&#x2F;声卡），都不需要勾选
WASAPI：是Windows管理音频流的底层接口，所有应用的音频数据最终都会通过 WASAPI 驱动到声卡或数字输出设备


Expand Mono to Stereo(将单声道扩展为立体声)，一般保持关闭即可，以避免对单声道源做不必要处理
Expand 6.1 to 7.1(将6.1声道扩展为7.1声道)，一般保持关闭即可，同上
Use Legacy Channel Layout(使用旧版声道布局)，一般保持关闭即可，除非设备不支持新版声道标准


Audio Delay(音频延迟)，基本用不上，保持关闭即可
Output Format(输出格式)，全部勾选
Mixing页，用于多声道到目标声道的混音
配置解读：
Output Speaker Configuration(输出扬声器配置)：可选Stereo、4.0、6.1、5.1、7.1、mono，建议与音频设备完全匹配
Center Mix Level(中心声道混音级别)：控制中心声道混入时的音量，一般是人声&#x2F;对白，按需微调
Surround Mix Level(环绕声道混音级别)：控制环绕声道混入时的音量，一般是音乐&#x2F;环境，按需微调
LFE Mix Level(LFE声道混音级别)：控制低音声道混入时的音量，一般是低音，按需微调
Don’t mix Stereo sources(不混音立体声源)：勾选后，立体声源将不会混音，而是直接输出，建议启用，以避免二次处理
Normalize Matrix(矩阵标准化)：勾选后，将对音频进行全局衰减，使其更安静(音量降低)，以确保音量单音频文件音量一致。虽然不会发生削波，但会导致不同源格式之间的音量不一致，如：立体声会比5.1声道更响亮，但播放单个文件时的音量不会改变，通常关闭，由下游均衡器或功放处理
若需全局响度一致，可在播放软件或系统级均衡器中另行处理；LAV 的 Normalize Matrix 更多用于特殊兼容性或录制场景


Clipping Prevention(防止剪切)：勾选后，保证声道叠加导致的削波失真（爆音），建议启用
Matrix Encoding(矩阵编码)：矩阵编码格式，自行选择





MadVR接下来是重头戏——MadVR的配置，MadVR的配置项非常多有关HDR的内容或许会补充(挖坑.png)，因为HDR(含Test Bulid)的配置项非常多，且复杂，我也没有观看HDR的需求而且我也没有hdr显示器，所以只能靠口胡ο(&#x3D;•ω＜&#x3D;)ρ⌒☆（被打screenshot(截图)我用不上，相信你也用不上，就不占篇幅了写的我快崩溃了X﹏X

如何进入MadVR配置页面：
在MPC-BE中，右键-选项-视频-视频渲染器，属性，点击Edit Settings，即可进入MadVR配置页面



devices(设备)

这里是选择你的设备类别以供MadVR识别
Receiver, Processor, Switch：信号处理&#x2F;切换设备，本身不是显示器，而是驱动以下显示终端的前端
Digital Monitor &#x2F; TV：LCD&#x2F;LED&#x2F;OLED&#x2F;QLED的显示器&#x2F;电视
Digital Projector：数字投影仪
CRT projector：CRT投影仪
CRT monitor ITV：CRT显示器
unknown：以上之外的设备
现代显示器一般是Digital Monitor &#x2F; TV

展开显示器配置
properties(属性)：  
output level(输出级别)：一般电脑选择PC levels(0-255)，电视选择TV levels(16-235)，但还是推荐确认一下你的显示器的输出级别，如果非这两个选项可以选择custom levels(自定义级别)，自行填写
bitdepth(位深)：选择auto，自动匹配即可，bitdepth是指显示器支持的颜色深度，常见的有8bit、10bit、12bit等，位深越高，颜色越丰富
3D format(3D格式)：一般选择auto，自动匹配即可


calibration(校准)：  
disable calibration for this display(禁用此显示器的校准)：勾选后，MadVR将不会对显示器进行校准
this display is already calibrated(此显示器已经校准)：勾选后，MadVR将不会对显示器进行校准，而是直接使用外部校准结果
gamut与gamma按照校准显示器时的参数填写即可


by using yCMS(使用yCMS)：勾选后，MadVR将使用yCMS进行校准
by using external 3DLUT files(使用外部3DLUT文件)：勾选后，MadVR将使用外部3DLUT文件进行校准，需要自行准备3DLUT文件
一般而言，如果显示器进行过专业校准，则勾选this display is already calibrated，没有经过校准则勾选或不确定色域则勾选disable calibration for this display


display modes(显示模式)：  
switch to matching display mode(切换到匹配的显示模式)：勾选后，MadVR将在符合条件时自动切换到匹配的显示模式
when playback starts(播放开始时)：勾选后，MadVR将在播放开始时切换到匹配的显示模式
when media player goes fullscreen(全屏时)：勾选后，MadVR将在全屏时切换到匹配的显示模式


restore original display mode(恢复原始显示模式)：勾选后，MadVR将在符合条件时恢复原始显示模式
when media player is closed(播放器关闭时)：勾选后，MadVR将在播放器关闭时恢复原始显示模式
when media player leaves fullscreen(退出全屏时)：勾选后，MadVR将在退出全屏时恢复原始显示模式


list all display modes MadVR switch to(列出MadVR切换到的所有显示模式)：如果要使用MadVR的显示模式切换功能，此项必须填屏幕支持的显示模式(如：1080p144、1920x1080p60)，否则自动切换不生效，可在Windows设置-系统—屏幕-高级显示设置-显示器x的显示适配器属性-列出所有显示模式中查看
treat 25p movies as 24p(将25p电影视为24p)：勾选后，MadVR将把25p电影视为24p，需要Reclock或VideoClock支持
hack Direct3D to make 24.000Hz and 60.000Hz work(将24.000Hz和60.000Hz的显示模式视为24.000Hz和60.000Hz)：勾选后，通过绕过 Direct3D 的默认限制，强制系统将显示器刷新率切换至精确的 24.000Hz 或 60.000Hz，而非系统可能锁定的近似值（如 23.976Hz 或 59.940Hz），会导致 presentation queues(显示队列) 填不满，增加掉帧风险，依个人喜好选择
分页custom modes(自定义模式)，是用于自定义显示模式的，也是madshi提供的Reclock替代方案，如果你对显示模式有特殊需求，可以自行修改，请阅读madshi的文档


color &amp; gamma(颜色与伽马)：  
这一页主要修改伽马，默认值会根据你在 calibration(校准) 的设置变化：
disable calibration ⟶ gamma：默认值2.2
如果有设置，则与你设置的伽马一致
一般来说，设置为2.2，然后根据环境光线动态调整，较暗环境下，伽马可以调高至2.4或更高，较亮环境下，伽马可以调低至2.0或更低


上方的颜色配置，一般不需要去改，有需要再去调整



processing(处理)
deinterlacing(反交错)：  
由于LAV已经提供反交错，madVR获得的信号是LAV处理过的，所以这里直接保持默认即可，配置翻译：
Automatically activate deinterlacing when needed (在需要时自动激活反交错)
if in doubt, activate deinterlacing (若有疑问，激活反交错)
if in doubt, deactivate deinterlacing (若有疑问，停用反交错)


disable automatic source type detection (禁用自动源类型检测)，不同模式反交错算法不同
force film mode (强制电影模式 - 适用于电影&#x2F;24fps内容)
force video mode (强制视频模式 - 适用于视频&#x2F;隔行内容)


only look at pixels in the frame center (仅检测画面中心的像素 - 适用于广播电视，对动画效果不佳)，如果会看电视台播放的节目的话，建议勾选此选项，如果是看DVD原盘的话，则建议取消勾选


artifact removal(去除伪影)：  
reduce banding artifacts (减少带状伪影&#x2F;去色带)
default debanding strength (默认去带强度)
strength during fade in&#x2F;out (淡入&#x2F;淡出时的强度)
概念解读：
banding artifacts(带状伪影)：即色带，是一种色彩显示不准确的问题，通常出现在低色深环境(4~8bit)。现在大多数片源(1080p)都是8bit，或多或少含有色带，视频解码时YUV ⟶ RGB，还会产生新的色带


推荐default debanding strength设置为low，strength during fade in&#x2F;out设置为medium/high，强度越高减少色带的效果越明显，但会产生噪点。淡入&#x2F;淡出时色带会很明显，所以设置为medium/high


reduce ringing artifacts (减少环状伪影)
reduce dark halos around bright edges, too(同时减少亮边缘周围的暗晕)
避免用于线条锐利的内容（动漫&#x2F;字幕&#x2F;工程图），reduce dark halos本质是抑制亮边周围的暗区过冲，但动漫的硬边缘（如发丝）会被误判为振铃导致细节丢失


概念解读：
ringing artifacts(环状伪影)：即振铃效应，是一种出现在信号快速转换时，附加在转换边缘上导致失真的信号。而在图像或影像上，振铃效应会导致出现在边缘附近的环带或像是“鬼影”的环状伪影，不恰当的缩放算法、锐化等操作都会导致这种伪影


推荐当观察到 ringing artifacts(环状伪影) 时，再启用此选项


reduce comprssion artifacts (减少压缩伪影)，旁边的项目用来控制强度和质量
该功能专门用于修复视频压缩产生的瑕疵（如色带、蚊式噪声、块效应等），开启后能显著去除网格式噪块，但也会略微模糊细节，推荐当需要时，再启用此选项
process chroma channels, too(同时处理色度通道)，修复色度通道的伪影（如彩色色带&#x2F;色块），性能开销较大，一般不启用，在色度伪影肉眼可见且GPU性能冗余时启用
activate only if it comes for free(as part of NGU sharp)(仅在NGU锐化的启用时激活)，若使用NGU时，强烈建议启用，可以减少NGU的伪影


reduce random noise (减少随机噪声)，旁边的项目用于控制强度
此项用于减少随机噪声，但会破坏细节，一般不启用，在噪声严重时启用
process chroma channels, too(同时处理色度通道)，同上




image enhancements(图像增强)：
这一页主要针对影片锐利度不足进行增强，影响原始帧，其处理在放大算法之前，该页面的配置项为锐化算法，不论哪种效果都十分显著，但噪声与瑕疵也会被放大，一般不启用，在需要时启用。锐化算法这里不做解释，自行Google


zoom contorl(缩放控制)：
根据黑边检测、分辨率变化与字幕位置，自动调整缩放或裁切策略，保证内容充满屏幕并保持字幕可见，自行按需调整，一般不需要启用，配置翻译：
disable scaling if image size changes by only … pixels(如果图像大小仅变化…像素则禁用缩放)，控制片源与目标分辨率差异低于几个像素时，不进行缩放，而添加黑边代替，避免频繁微调影响流畅性
move subtitles(移动字幕)，强制设置字幕的位置是画面底部或是影片可视范围内
automatically detect hard coded black bars(自动检测硬编码黑边)，自动检测硬编码黑边，并非比例不一致添加的黑边，而是影片本身编码时添加的黑边
if black bars change pick one zoom factor，黑边尺寸变化时，选择不裁剪画面内容的缩放比例、砍除25%黑边、砍除50%黑边、砍除75%黑边、砍除全部黑边
if black bars change quickly back and forth，如果黑边尺寸变化频繁
当低于2&#x2F;5&#x2F;15&#x2F;45秒时，不切换缩放比例
设定通用的缩放比例


notify media player about cropped black bars，控制每隔多久通知一次播放器黑边尺寸变化
always shift the image，总是切齐画面底部&#x2F;顶部
keep bars visible if they contain subtitles，如果上面有字幕的话保留黑边（字幕出现后保留黑边5秒、15秒、45秒、3分、10分、30分、90分或永远）
clearup image borders by cropping，裁切黑边以及其边缘指定像素
if there are big black bars，如果黑边大小超过范围，直接裁切黑边一定尺寸并放大
zoom small black bars away，如果黑边小范围，直接裁切黑边并放大
crop black bars，裁切黑边以及其边缘指定像素，会影响到profile的判定（如果有设置的话）



scaling algorithms(缩放算法)
chroma upscaling(色度升频)、image downscaling(图像降频)、image upscaling(图像升频)，这三个选项是色度放大与图像的放大、缩小算法的配置，配置页注明了sharpness(锐度)、hide source artifacts(隐藏源伪影)、ringing(振铃效应)、other artifacts(其他伪影)，其中绿色为效果，红色为失真，不同算法效果、与性能开销不同，请自行权衡
推荐：
色度升频算法优先推荐使用NGU + Sharp；性能不足的话，尝试NGU + Anti-Alias&#x2F;soft；其次是super-xbr + anti-alias以及Bilinear + anti-alias；最次Cubic(Bicubic 75) + anti-alias。anti-ringing filter能开就开，SuperRes filter自行权衡
图像升频同样优先推荐NGU Sharp；性能不足的话尝试NGU Anti-Alias&#x2F;soft；其次是Cubic(Bicubic 100)、Lanczos等，使用这几种时，anti-ringing filter能开就开，而 scale in sigmoidal light(对数光) 的降低锯齿效果需要自己测试。Bilinear和DXVA2效果最次，仅作无法负荷其他算法时使用。使用NGU系列时只需要指定 luma doubling(亮度解析度翻倍) 和 luma quadrupling(亮度解析度四倍) 的强度，其余 let madVR decide(让madVR决定) 即可。
图像降频算法优先推荐使用SSIM，1D是基于Bicubic的，2D是基于Jinc的，2D效果更好，但性能开销更大；性能不足的话，尝试Cubic(Bicubic 150)。scale in linear light(线性光) 与 anti-ringing filter(抗振铃) 能开就开，抗振铃的strict（soft）跟relaxed，前者是AR滤镜预设强度，后者是降低AR滤镜强度，换得一些锐利度的提升；activate anti-bloating filter(抗膨胀滤镜)，它会抑制因过度锐化导致的高频信号’膨胀’或’白边’伪影，是否启用取决于个人喜好
每个设置项的low、medium、high、very high均是越高性能开销越大，但效果越好，请自行权衡。
关于图片升频，现在的madVR版本，使用NGU系列时只需要指定 luma doubling(亮度倍增) 和 luma quadrupling(亮度四倍) 的强度，其余 let madVR decide(让madVR决定) 即可
关于always - supersampling(强制超取样)，选择此项的话即使在源分辨率与目标分辨率一致时，也会强制使用升频算法，而且效果肉眼基本看不出，但性能开销很大，请自行权衡


upscaling refinement(升频优化)，它的副作用相对前面的 image enhancements(图像增强) 要小，效果差不多，同样一般不启用，在需要时启用，缩放算法自行Google

rendering(渲染)
general settings(通用设置)：  
delay playback start until render queue is full(延迟播放直到渲染队列满)，避免播放器卡顿
delay playback start after seeking, too(在快进后也延迟播放)，避免播放器卡顿


enable windowed overlay(启用窗口化覆盖模式)，启用窗口化覆盖模式(游戏的无边框窗口模式)，能绕过部分桌面合成步骤，降低延迟和资源占用，和下面的全屏独占模式二选一
enable automatic fullscreen exclusive mode(启用自动全屏独占模式)，启用全屏独占模式，能使渲染器直接控制显示输出，绕过DWM，和上面的窗口化覆盖模式二选一，推荐此项
disable desktop composition(禁用窗口管理器)(仅Win7)，禁用DWM，获得类似全屏独占模式的效果，但渲染能获得更直接的显示权限，Windows 8及以后版本不支持
only when media player is in fullscreen mode(仅在播放器全屏时启用)


use Direct3D 11 for presentation(使用Direct3D 11进行呈现)，使用Direct3D 11 API进行呈现，性能比Direct3D 9好
present a frame for every VSync(每个垂直同步呈现一帧)，即常说的垂直同步，这要求视频帧率必须能被显示器刷新率整除(或配置上文的display modes)，否则画面可能卡顿


use a separate device for presentation(使用单独的设备进行呈现)，让 madVR 为“呈现”(Presentation) 操作（将最终处理好的帧发送到显示器）使用一个独立的 Direct3D 设备（和上下文），这能减少对视频解码的干扰
use a separate device for DXVA processing(使用单独的设备进行DXVA处理)，让 madVR 为 DXVA 处理（视频解码）使用一个独立的 Direct3D 设备（和上下文），也是隔离策略
剩下的滑块CPU queue size(CPU队列大小)、GPU queue size(GPU队列大小)，控制渲染队列的大小，滑块越大，渲染队列越大，能减少卡顿，但会占用更多RAM，请自行权衡


windowed mode(窗口模式)：  
present several frames in advance(提前呈现几帧)，提前呈现几帧以减少卡顿，建议资源允许时启用
how many video frames shall be presented in advance(提前呈现多少帧视频)，如果启用提前帧，会显示此项，按照GPU性能自行调整，越高减少卡顿的效果越好，但RAM占用越大，请自行权衡。如果使用smooth motion(平滑运动)，建议能拉多高就拉多高，也要相应地增加CPU&#x2F;GPU队列以填充缓冲区
how many backbuffers shall be used(使用多少个后台缓冲区)，如果未启用提前帧，会显示此项，按照RAM自行调整，越高效果越好，但性能开销越大，请自行权衡
when and how shall the GPU be flushed(何时以及如何刷新GPU)：
GPU 刷新（Flush）的作用：GPU 任务以命令队列形式提交，刷新会强制 GPU 立即执行队列中的所有任务，确保后续操作基于最新结果。频繁刷新会导致性能下降，画面卡顿，对于大多数设备默认方案就是最好的选择，但某些设备可能需要调整刷新策略
after intermediate render steps(在中间渲染步骤后)
after last render step(在最后渲染步骤后)
after copy to backbuffer(在复制到后台缓冲区后)
after D3D presentation(在DXGI呈现后)




exclusive mode(独占模式)：  
show seek bar(显示进度条)，启用后，在播放器全屏时，会显示一个MadVR提供的进度条
delay switch to exclusive mode by 3 seconds(延迟3秒切换到独占模式)，不勾选则立即切换到独占模式
其余配置项同windowed mode(窗口模式)


stereo 3D(立体3D)：
这一部分是有播放3D视频需求时才需要配置的，一般全部取消勾选
enable stereo 3D playback(启用立体3D播放)，启用立体3D播放，需要配合立体3D视频播放
when playing 2d content(播放2D内容时)，控制播放2D内容时是否禁用3D支持
when playing 3d content(播放3D内容时)，控制播放3D内容时是否禁用3D支持
restore os stereo 3D settings when meida player closed(在媒体播放器关闭时恢复操作系统立体3D设置)


smooth motion(平滑运动)：
这个功能(FRC)能够将任何源帧率转换为任何目标刷新率，在性能足够的情况下，可以达到不使用Reclock达到无卡顿&#x2F;无重复的效果
FRC实现原理不是补帧，按madshi的说法：“FRC 模拟了一个具有无限刷新率的显示器，每个视频帧都会在时间戳要求的精确时刻显示。因此，运动的流畅度取决于正确的时间戳。如果时间戳（或音频时钟）存在抖动，播放也会出现抖动… 完全启用 Reclock 并进行音频重采样仍然是可行的，这不会对 madVR 的 FRC 算法造成损害。” 因此它不具有补帧算法的副作用（如伪影、肥皂剧效应），运动相对自然。代价是轻微的清晰度损失（动态模糊感略有增加）和 GPU 使用率升高（损失程度：低帧率-&gt;高刷新率 &lt; 高帧率-&gt;低刷新率）
与补帧插件建议二选一
建议：如果追求绝对流畅无 judder 且能接受轻微的清晰度损失和 GPU 开销增加，勾选enable smooth motion并选择 …or if the display refresh rate is an exact multiple of the video frame rate ，希望控制GPU开销，选择only if there would be motion judder without it…，always不推荐
enable smooth motion frame rate conversion(启用平滑运动帧率转换)
only if there would be motion judder without it…(只有在没有它的情况下才会出现运动抖动时才启用)，仅在视频帧率不能整除显示器刷新率，产生可见抖动时启用
…or if the display refresh rate is an exact multiple of the video frame rate(或者如果显示刷新率是视频帧率的精确倍数)，它在上一条件的基础上拓展，在显示刷新率是视频帧率的精确倍数时也会启用
always(总是)，无论当前视频帧率和显示器刷新率的关系如何（无论是否整数倍，无论是否有抖动风险），都强制启用




dithering(抖动)：
None，不应用任何抖动处理（可能导致色带问题）十分不建议
Random Dithering(随机抖动)，噪声明显，速度快，无抖动图案，极低能耗
Ordered Dithering(有序抖动)，错误扩散的轻量替代方案，噪声较少，中等抖动图案，低能耗
Error Diffusion - option 1(错误扩散 - 选项1)，中等噪声，无抖动图案(需要DX11 GPU)
Error Diffusion - option 2(错误扩散 - 选项2)，低噪声，中等抖动图案(需要DX11 GPU)
options：
use colored noise(使用彩色噪声)，低亮度噪声，会增加色度噪声，优化人眼感知，减少可见噪点
change dither for every frame(为每一帧更改抖动)，隐藏抖动图案，避免固定图案导致的静态闪烁，但主观上增加噪声感


推荐：如果 GPU支持DX11，优先选择Error Diffusion - option 1并勾选use colored noise 和change dither for every frame。这是效果和性能的良好平衡。追求极致选 option 2。性能不足选 Ordered Dithering


trade quality for performance(以质量为代价换取性能)：
这一页所有项目都是牺牲质量换性能，如果性能足够，一个也不建议勾选！！
optimize subtitle quality performance instead of quality(优先以性能优化字幕渲染)，降低字幕渲染精度以节省资源
use DXVA chroma upscaling when doing native DXVA decoding(原生DXVA解码时使用DXVA色度升频)，用硬件加速色度处理（可能产生锯齿）
use DXVA chroma upscaling when doing DXVA deinterlacing(DXVA反交错时使用DXVA色度升频)，硬件加速反交错+色度升频（画质损失明显）
don’t use linear light for dithering(抖动处理不使用线性光空间)，关闭线性光抖动（暗部细节减少）
don’t analyze gradient angles for debanding(去色带时不分析渐变角度)，简化梯度计算（可能导致带状伪影残留）
don’t rerender frames when fade in&#x2F;out is detected(检测到淡入&#x2F;淡出时不重新渲染帧)，跳过透明度变化的帧处理（过渡不自然）
scale chroma separately, if it saves performance(若可提升性能则单独处理色度通道)，色度&#x2F;亮度分离处理（可能色彩错位）
compromise on HDR tone &amp; gamut mapping accuracy(降低HDR色调 &amp; 色域映射精度)，简化 HDR 动态转换（色彩准确性下降）
compromise on HDR luminance channel quality(降低HDR亮度通道质量)，压缩高光细节（亮部层次减少）
don’t measure HDR frame peak luminance(不测量HDR帧峰值亮度)，禁用逐帧亮度分析（局部过曝风险）
lose BTB and WTW if it improves performance(若可提升性能则牺牲超黑&#x2F;超白细节 (BTB&#x2F;WTW))，裁剪 &lt;0 或 &gt;255 灰阶（丢失极端暗&#x2F;亮部）
don’t use linear light for smooth motion frame blending(平滑插帧不使用线性光混合)，简化帧混合计算（运动流畅度下降）
use 10bit chroma buffer instead of 16bit(使用10bit色度缓冲代替16bit)，降低色度数据精度（色彩过渡轻微断层）
use 10bit image buffer instead of 16bit(使用10bit图像缓冲代替16bit)，全局降低处理精度（所有画质影响）
run custom pixel shaders in video levels instead of PC levels(在视频电平（16-235）而非PC电平（0-255）运行自定义像素着色器)，简化色域转换（暗部发灰&#x2F;亮部过曝）
强烈不建议使用的选项，但决定权在你：
use half frame rate for DXVA deinterlacing(DXVA反交错使用半帧率)，帧数减半（运动卡顿明显，仅兼容老式隔行视频）
trust DXVA color &amp; levels conversion(任DXVA的色彩与电平转换)，绕过 madVR 色彩管理（色偏&#x2F;灰阶错误高发）





尾声至此，播放器的配置就完成了，如果还有其他问题，请善用搜索引擎，或者翻翻madshi的帖子更新日志，Test Build(HDR)祝你有个愉快的观影体验！
常见问题 Q&amp;A
Q：笔记本&#x2F;非独显直连&#x2F;只有核显，播放时画面卡顿怎么办？

A：这是因为渲染的压力全部分给了核显与CPU。解决方法(按顺序尝试):
是否有独显，若有尝试b&#x2F;c；若没有，尝试降低&#x2F;关闭绝大部分madVR配置
在独显驱动中使播放器优先使用独显
若尝试b仍卡顿，尝试降低madVR配置：
优先降低&nbsp;色度升频&nbsp;配置，此项性能开销较大，而且降低强度也不会有明显画质损失
其次是 降低&nbsp;图像升频&nbsp;或&nbsp;图像降频&nbsp;配置 ，此项性能开销较大，而且降低强度会有明显画质损失，因此建议在降低色度升频强度后尝试
最后尝关闭smooth motion，此项性能开销较大，而且关闭后可能产生抖动
尝试以上后若仍无改善，考虑逐次尝试开启trade quality for performance中的选项






Q：播放时画面卡顿甚至黑屏，但CPU占用率不高，GPU占用率很低甚至为0%，但温度很高，风扇狂转，怎么办？

A：倘若显卡驱动正常，则可能是因为显卡过热停机&#x2F;降频，尝试Q.1中的方法，然后重启设备；播放时观察显卡占用率，推荐保证占用低于80%，否则显卡过热风险较高，也会影响显卡寿命


Q：没有声音，怎么办？

A：确认是否在设备不支持的情况下启用了Bitstream，若确认，尝试关闭Bitstream或勾选Fallback to PCM if Bitsreaming is not supported；若仍有问题，尝试更换音频输出设备



]]></content>
      <categories>
        <category>折腾日记</category>
        <category>长文</category>
      </categories>
      <tags>
        <tag>MadVR</tag>
        <tag>LAVFilters</tag>
      </tags>
  </entry>
  <entry>
    <title>「折腾日记」hexo-butterfly自改记录</title>
    <url>/posts/653f0679/index.html</url>
    <content><![CDATA[前言记录一下自己折腾hexo-butterfly主题的记录，方便以后查阅2025.06.26更新:

此文不再更新，修改后的主题已同步至theme分支，不定时更新
修改了默认的loading动画，增加了Hitokoto文本
增加动态标题
参考Heo同款loading动画增加了Hitokoto文本



修改loading动画1.修改&#x2F;themes&#x2F;butterfly&#x2F;source&#x2F;css&#x2F;_layout&#x2F;loading.stylif hexo-config(&#x27;preloader&#x27;)  .loading-bg    display: flex;    width: 100%;    height: 100%;    position: fixed;    background: linear-gradient(-135deg, #E2B0FF 10%, #f295c7 30%, #4e9ce4 90%, #23d5ab 100%);    z-index: 1001;    opacity: 1;    transition: .3s;    background-size: 400% 400%;    animation: backgroundglow 8s ease-in-out infinite;  #loading-box    .loading-img      width: 100px;      height: 100px;      border-radius: 50%;      margin: auto;      border: 4px solid #f0f0f2;      animation-duration: .3s;      animation-name: loadingAction;      animation-iteration-count: infinite;      animation-direction: alternate;    .loading-image-dot      width: 30px;      height: 30px;      background: linear-gradient(135deg, #E2B0FF 10%, #f295c7 50%, #4e9ce4 90%, #23d5ab 100%);      position: absolute;      border-radius: 50%;      border: 6px solid #fff;      top: 50%;      left: 50%;      transform: translate(18px, 24px);    &amp;.loaded      .loading-bg        opacity: 0;        z-index: -1000;    #hitokoto-text    position: absolute    top: 68%    left: 50%    transform: translate(-50%, -50%)    width: 80%    max-width: 600px    padding: 10px    font-size: 24px    color: #fff    text-align: center    background: rgba(0, 0, 0, 0)    border-radius: 8px    z-index: 1002    animation: fadeIn 1s ease-in-out  @keyframes loadingAction    0% &#123;        opacity: 1;    &#125;    100% &#123;        opacity: .4;    &#125;  @keyframes backgroundglow    0% &#123;        background-position: 0% 50%;    &#125;    50% &#123;        background-position: 100% 50%;    &#125;    100% &#123;        background-position: 0% 50%;    &#125;  @keyframes fadeIn    0% &#123;        opacity: 0;    &#125;    100% &#123;        opacity: 1;    &#125;

2.修改&#x2F;themes&#x2F;butterfly&#x2F;layout&#x2F;includes&#x2F;loading&#x2F;fullpage-loading.pug#loading-box(onclick=&#x27;this.classList.add(&quot;loaded&quot;)&#x27;)  .loading-bg    .loading-img    .loading-image-dot    #hitokoto-textscript.  (()=&gt;&#123;    function getHitokoto() &#123;      const hitokotoEl = document.getElementById(&#x27;hitokoto-text&#x27;);      if (!hitokotoEl) return;      fetch(&#x27;https://v1.hitokoto.cn&#x27;)        .then(response =&gt; response.json())        .then(data =&gt; &#123;          hitokotoEl.innerText = data.hitokoto;        &#125;)        .catch(() =&gt; &#123;          hitokotoEl.innerText = &#x27;🐱喵喵喵🐱&#x27;;        &#125;)    &#125;    const $loadingBox = document.getElementById(&#x27;loading-box&#x27;)    const $body = document.body    const preloader = &#123;      endLoading: () =&gt; &#123;        $body.style.overflow = &#x27;&#x27;        $loadingBox.classList.add(&#x27;loaded&#x27;)      &#125;,      initLoading: () =&gt; &#123;        $body.style.overflow = &#x27;hidden&#x27;        $loadingBox.classList.remove(&#x27;loaded&#x27;)        getHitokoto()      &#125;    &#125;    preloader.initLoading()    window.addEventListener(&#x27;load&#x27;, preloader.endLoading)    if (!&#123;theme.pjax &amp;&amp; theme.pjax.enable&#125;) &#123;      btf.addGlobalFn(&#x27;pjaxSend&#x27;, preloader.initLoading, &#x27;preloader_init&#x27;)      btf.addGlobalFn(&#x27;pjaxComplete&#x27;, preloader.endLoading, &#x27;preloader_end&#x27;)    &#125;  &#125;)()

3.修改&#x2F;themes&#x2F;butterfly&#x2F;layout&#x2F;includes&#x2F;loading&#x2F;index.pugif theme.preloader.enable  if theme.preloader.source === 1    include ./fullpage-loading.pug  else if theme.preloader.source === 2    include ./pace.pug  else    include ./fullpage-loading.pug    include ./pace.pug

4.新建&#x2F;source&#x2F;css&#x2F;loading_bar.css.pace &#123;  -webkit-pointer-events: none;  pointer-events: none;  -webkit-user-select: none;  -moz-user-select: none;  user-select: none;  z-index: 2000;  position: fixed;  margin: auto;  top: 18px;  left: 0;  right: 0;  height: 8px;  border-radius: 8px;  width: 10rem;  background: rgba(255, 255, 255, 0.2);  border: 1px #e3e8f7;  overflow: hidden;&#125;.pace-inactive .pace-progress &#123;  opacity: 0;  transition: 0.3s ease-in;&#125;.pace .pace-progress &#123;  -webkit-box-sizing: border-box;  -moz-box-sizing: border-box;  -ms-box-sizing: border-box;  -o-box-sizing: border-box;  box-sizing: border-box;  -webkit-transform: translate3d(0, 0, 0);  -moz-transform: translate3d(0, 0, 0);  -ms-transform: translate3d(0, 0, 0);  -o-transform: translate3d(0, 0, 0);  transform: translate3d(0, 0, 0);  max-width: 200px;  position: absolute;  z-index: 2000;  display: block;  top: 0;  right: 100%;  height: 100%;  width: 100%;  background: linear-gradient(90deg, #E2B0FF 0%, #f295c7 40%, #4e9ce4 70%, #23d5ab 100%);  animation: gradient 1.5s ease infinite;  background-size: 200%;  box-shadow: 0 0 10px rgba(126, 87, 194, 0.5), 0 0 20px rgba(126, 87, 194, 0.5);&#125;.pace.pace-inactive &#123;  opacity: 0;  transition: 0.3s;  top: -30px;&#125;@keyframes gradient &#123;  0% &#123;    background-position: 0% 50%;  &#125;  50% &#123;    background-position: 100% 50%;  &#125;  100% &#123;    background-position: 0% 50%;  &#125;&#125;

5.新建&#x2F;source&#x2F;css&#x2F;loading_img.css.loading-img &#123;  background: url(你的头像地址) no-repeat center center;  background-size: cover;&#125;

6.新建&#x2F;source&#x2F;js&#x2F;hotokoto.jsdocument.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123;  const hitokotoEl = document.getElementById(&#x27;hitokoto-text&#x27;);  if (!hitokotoEl) return;  fetch(&#x27;https://v1.hitokoto.cn/&#x27;)     .then(response =&gt; response.json())    .then(data =&gt; &#123;      hitokotoEl.textContent = data.hitokoto;    &#125;)    .catch(() =&gt; &#123;      hitokotoEl.textContent = &#x27;喵喵喵~&#x27;;    &#125;);&#125;);

7.修改_config.butterfly.yml# Loading Animationpreloader:  enable: true  # source  # 1. fullpage-loading  # 2. pace (progress bar)  source: 3 # 改为3,同时加载fullpage-loading和pace  # pace theme (see https://codebyzach.github.io/pace/)  pace_css_url: /css/loading_bar.css...# Inject# Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)inject:  head:    # - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;    - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/loading_img.css&quot;&gt;  bottom:    # - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;    - &lt;script src=&quot;/js/hitokoto.js&quot;&gt;&lt;/script&gt;

添加动态标题1.新建&#x2F;source&#x2F;js&#x2F;dynamic_title.jsdocument.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123;  const leave = &#x27;离开页面时的标题&#x27;;  const back = &#x27;返回页面时的标题&#x27;;  const defaultTitle = document.title;    document.addEventListener(&#x27;visibilitychange&#x27;, function() &#123;    if (document.visibilityState === &#x27;hidden&#x27;) &#123;      document.title = leave;      clearTimeout(titleTime);    &#125; else &#123;      document.title = back;      titleTime = setTimeout(() =&gt; &#123;        document.title = originTitle;      &#125;, 5000);    &#125;  &#125;);&#125;)
此js文件的作用是，当用户离开页面时，标题会变成“离开页面时的标题”，当用户返回页面时，标题会变成“返回页面时的标题”，并在5秒后恢复为原来的标题
2.修改_config.butterfly.yml# Inject# Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)inject:  head:    # - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;    - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/loading_img.css&quot;&gt;  bottom:    # - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;    - &lt;script src=&quot;/js/hitokoto.js&quot;&gt;&lt;/script&gt;    - &lt;script src=&quot;/js/dynamic_title.js&quot;&gt;&lt;/script&gt;

测试hexo cl &amp;&amp; hexo g &amp;&amp; hexo s

loading效果
]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>「折腾日记」记录Windows下MSYS2+Nodejs+Python开发环境搭建</title>
    <url>/posts/58031fe8/index.html</url>
    <content><![CDATA[0. 前言最近在折腾Windows下的开发环境，发现MSYS2是一个非常强大的工具，十分适合我这种喜欢极致轻量化的人做此记录，以便日后查阅

主要优势：

轻量化（相比臃肿的MSVC）
Unix工具链的Windows实现
完善的包管理系统


1. 安装MSYS2环境选择
MSYS2 提供了不同的环境，这些环境之间的主要区别在于工具链和实现。如果不确定使用哪个，请选择 UCRT64：




Name
Prefix
Toolchain
Architecture
C Library
C++ Library



MSYS
&#x2F;usr
gcc
x86_64
cygwin
libstdc++


UCRT64
&#x2F;ucrt64
gcc
x86_64
ucrt
libstdc++


CLANG64
&#x2F;clang64
llvm
x86_64
ucrt
libc++


CLANGARM64
&#x2F;clangarm64
llvm
aarch64
ucrt
libc++


MINGW64
&#x2F;mingw64
gcc
x86_64
msvcrt
libstdc++



Note:路径说明：安装路径示例：C:\msys2\ucrt64软件安装路径：对应环境的bin目录，例如：C:\msys2\ucrt64\bin

安装基本编译器：#可选：使用tuna镜像sed -i &quot;s#https\?://mirror.msys2.org/#https://mirrors.tuna.tsinghua.edu.cn/msys2/#g&quot; /etc/pacman.d/mirrorlist*pacman -Syu # 更新软件包数据库并升级系统，需要重启MSYS2pacman -S pactoys # 安装pactoyspacboy -S toolchain zsh # 安装工具链、zshpacman -S git # 安装git

Note:

pactoys 是MSYS2提供的软件包管理工具，它功能与pacman基本相同，但是它可以直接安装对应环境的软件包，例如：UCRT64环境下pacboy -S gcc等价于pacman -S mingw-w64-ucrt-x86_64-gcc。


2. 配置环境变量环境变量注意：
⚠️危险操作（避免冲突）：不要将 &#x2F;usr&#x2F;bin 加入系统PATH

推荐配置：只添加对应环境的bin目录：C:\msys2\ucrt64\bin


Windows Terminal配置替代方案详见Step.7

在 Windows Terminal 的配置文件中，添加如下内容：

&quot;list&quot;: [   &#123;       &quot;commandline&quot;: &quot;C:\\msys2\\msys2_shell.cmd -defterm -here -no-start -ucrt64 -shell zsh&quot;,      &quot;guid&quot;: &quot;&#123;fd57d26d-d3d0-448a-8bd5-e44632685d72&#125;&quot;,      &quot;hidden&quot;: false,      &quot;icon&quot;: &quot;C:\\msys2\\ucrt64.ico&quot;,      &quot;name&quot;: &quot;MSYS2 UCRT64&quot;,      &quot;startingDirectory&quot;: &quot;C:\\msys2\\home\\%USERNAME%&quot;   &#125;]

Note:

如果你不使用zsh，可以将-shell zsh修改为-shell bash等。
你也可以在GUI中添加，以上参数分别对应：


参数
说明



commandline
命令行


icon
图标


name
名称


startingDirectory
启动目录



有关zsh的相关配置，这里不再赘述


3. 配置开发环境VSCode + gccVSCode + clangNeovim + clang
vscode 必备插件：

C&#x2F;C++
C&#x2F;C++ Extensions
CMake Tools
Code Runner


C++插件配置(.vscode/c_cpp_properties.json)示例：


&#123;    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;Win32&quot;,                    &quot;includePath&quot;: [                &quot;$&#123;workspaceFolder&#125;/**&quot;,                &quot;C:/msys2/ucrt64/include/**&quot;            ],            &quot;defines&quot;: [],            &quot;compilerPath&quot;: &quot;C:/msys2/ucrt64/bin/gcc.exe&quot;,  //编译器路径            &quot;cStandard&quot;: &quot;c11&quot;,            &quot;cppStandard&quot;: &quot;c++17&quot;,            &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;        &#125;    ],    &quot;version&quot;: 4&#125;
vscode 必备插件：

Clangd
Cmake Tools
Code Runner


配置clangd与coderunner，在settings.json中添加如下内容：


&#123;  &quot;clangd.path&quot;: &quot;C:\\msys2\\clang64\\bin\\clangd.exe&quot;,  &quot;code-runner.executorMap&quot;: &#123;    &quot;c&quot;: &quot;cd $dir &amp;&amp; clang $fileName -o $fileNameWithoutExt &amp;&amp; ./$fileNameWithoutExt&quot;,    &quot;cpp&quot;: &quot;cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt &amp;&amp; ./$fileNameWithoutExt&quot;  &#125;&#125;这部分内容算是提供一种思路 实际上我不太习惯neovim，所以没有深入研究(*&#x2F;ω＼*)

在msys2中安装neovim：

pacboy -S neovim


配置LazyVim：
官方文档：LazyVim



git clone https://github.com/LazyVim/starter $env:LOCALAPPDATA\nvimRemove-Item $env:LOCALAPPDATA\nvim\.git -Recurse -Forcenvim
等待安装即可

配置基本语言服务器：
在Neovim中，按下&lt;Space&gt;cm，打开Mason
选择clangd，按下i安装



推荐阅读Dusty Phillips的模态编辑书籍：LazyVim for Ambitious Developers

4. Qt环境
在 MSYS2，输入以下命令安装Qt：

pacboy -S qt-creator # 安装qt-creatorpacboy -S qt6 # 安装qt6#按需安装pacboy -S qt6-static # 安装qt6静态库


在 PowerShell或MSYS2 中，运行以下命令，启动Qt Creator：

qtcreator

5. Node.js环境使用nvm管理Node.js版本
安装 nvm for Windows

nvm node_mirror https://npmmirror.com/mirrors/node/ # 设置nodejs镜像nvm npm_mirror https://npmmirror.com/mirrors/npm/ # 设置npm镜像nvm install lts # 安装最新的LTS版本nvm use lts # 使用最新的LTS版本

关于配置文件详见：nvm wiki
6. Python环境使用MiniConda管理Python版本
MiniConda
常用命令：

conda create -n myenv python=3.8 # 创建一个名为myenv的虚拟环境，并安装Python 3.8conda activate myenv # 激活myenv虚拟环境conda deactivate # 退出虚拟环境conda install numpy # 在当前虚拟环境中安装numpyconda remove numpy # 在当前虚拟环境中卸载numpyconda env list # 列出所有虚拟环境conda env remove -n myenv # 删除myenv虚拟环境

7. Powershell增强使用 PowerShell 7
提示符美化
主题框架：oh-my-posh  
字体：Nerd Fonts


PSReadLine
历史命令预测
Tab菜单补全
上下箭头历史搜索


实用工具别名
常用别名：’which’、’pnpmAL’、’pnpmALG’
Conda环境管理：’MiniConda’、’condaA’、’condaD’
MSYS2快捷启动：’msys2’
Eza用作ls，并沿用Linux使用习惯
若不想使用Eza，请将 Eza Function(行73到末尾) 部分删除




详细配置文件（记得替换Conda和Msys2路径）：

oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\montys.omp.json&quot; | Invoke-Expression #载入oh-my-posh主题Set-Alias -Name &#x27;which&#x27; -Value &#x27;Get-Command&#x27; # 设置别名，将which命令映射到Get-Command命令Set-PSReadLineOption -PredictionSource History # 设置PSReadLine的预测源为历史记录Set-PSReadLineKeyHandler -Key Tab -Function MenuComplete # 设置Tab键的键处理函数为MenuComplete，用于自动补全Set-PSReadLineKeyHandler -Key UpArrow -ScriptBlock &#123;  # 设置向上箭头键的键处理函数，用于向上搜索历史记录[Microsoft.PowerShell.PSConsoleReadLine]::HistorySearchBackward()[Microsoft.PowerShell.PSConsoleReadLine]::EndOfLine()&#125;Set-PSReadLineKeyHandler -Key DownArrow -ScriptBlock &#123; # 设置向下箭头键的键处理函数，用于向下搜索历史记录[Microsoft.PowerShell.PSConsoleReadLine]::HistorySearchForward()[Microsoft.PowerShell.PSConsoleReadLine]::EndOfLine()&#125;#Pnpm AliasesFunction pnpmAL &#123;    pnpm approve-builds&#125;Function pnpmALG &#123;    pnpm approve-builds --global&#125;#End Of Pnpm Aliases#Explorer AliasesFunction Exf &#123;    param(        [Parameter(Mandatory = $false)]        [string]$Path    )    if ($Path) &#123;        explorer $Path    &#125; else &#123;        explorer .    &#125;&#125;#End Of Explorer Aliases#Conda AliasesFunction MiniConda &#123;    param(        [Parameter(Mandatory = $false)]        [string]$EnvName    )    &amp; &#x27;D:\MiniConda\shell\condabin\conda-hook.ps1&#x27; ##修改&#x27;D:\MiniConda&#x27;为你的MiniConda路径    conda activate &#x27;D:\MiniConda&#x27; ##修改&#x27;D:\MiniConda&#x27;为你的MiniConda路径    if ($EnvName) &#123;        conda activate $EnvName    &#125;&#125;Function condaA &#123;    param(        [Parameter(Mandatory = $true)]        [string]$EnvName    )    conda activate $EnvName&#125;Function condaD &#123;    param(        [Parameter(Mandatory = $false)]        [string]$EnvName    )    if ($EnvName) &#123;        conda deactivate $EnvName    &#125; else &#123;        conda deactivate    &#125;&#125;#End Of Conda Aliases#MSYS2 FunctionsFunction Msys2 &#123;    &amp; &#x27;D:\MSYS2\msys2_shell.cmd&#x27; -defterm -no-start -clang64 -shell zsh ##修改&#x27;D:\MSYS2&#x27;为你的msys2路径;修改-clang64为你的环境&#125;#End Of MSYS2 Functions#Eza Functions$eza_params = @(    &#x27;--git&#x27;, &#x27;--icons&#x27;, &#x27;--group&#x27;, &#x27;--group-directories-first&#x27;,    &#x27;--time-style=long-iso&#x27;, &#x27;--color-scale=all&#x27;)Function ezals &#123;    param(        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]        [string[]]$EParams = @()    )    eza ($eza_params + $EParams)&#125;Set-Alias -Name &#x27;ls&#x27; -Value &#x27;ezals&#x27;Function l &#123;    param(        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]        [string[]]$EParams = @()    )    eza --git-ignore ($eza_params + $EParams)&#125;Function ll &#123;    param(        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]        [string[]]$EParams = @()    )    eza --all --header --long ($eza_params + $EParams)&#125;Function llm &#123;    param(        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]        [string[]]$EParams = @()    )    eza --all --header --long --sort=modified ($eza_params + $EParams)&#125;Function la &#123;    param(        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]        [string[]]$EParams = @()    )    eza -lbhHigUmuSa ($eza_params + $EParams)&#125;Function lx &#123;    param(        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]        [string[]]$EParams = @()    )    eza -lbhHigUmuSa@ ($eza_params + $EParams)&#125;Function lt &#123;    param(        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]        [string[]]$EParams = @()    )    eza --tree ($eza_params + $EParams)&#125;Function tree &#123;    param(        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]        [string[]]$EParams = @()    )    eza --tree ($eza_params + $EParams)&#125;#End Of Eza Functions

8. 结语完成后，你将获得：

✅ MSYS2
✅ C&#x2F;C++
✅ Qt
✅ Node.js
✅ Python

记录完]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>开发</tag>
        <tag>MSYS2</tag>
        <tag>Node.js</tag>
        <tag>Qt</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>「折腾日记」优质开源软件集</title>
    <url>/posts/12f010f8/index.html</url>
    <content><![CDATA[系统工具开发工具效率工具媒体工具文件管理网络工具命令行增强浏览器插件
Bulk-Crap-Uninstaller  

强大的Windows软件管理工具  
如果你不熟悉Windows，请谨慎使用


PowerToys  

微软官方出品的开源Windows工具集


Nilesoft Shell  

自定义右键菜单，替换Win11右键菜单


bleachbit  

开源清理工具  
请谨慎使用


Rufus

启动盘制作工具



PowerShell 7  
主题框架：oh-my-posh  
字体：Nerd Fonts
必备配置：



oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\montys.omp.json&quot; | Invoke-ExpressionSet-Alias -Name &#x27;ls&#x27; -Value &#x27;eza&#x27;Set-PSReadLineOption -PredictionSource HistorySet-PSReadLineKeyHandler -Key Tab -Function MenuCompleteSet-PSReadLineKeyHandler -Key UpArrow -ScriptBlock &#123;     [Microsoft.PowerShell.PSConsoleReadLine]::HistorySearchBackward()    [Microsoft.PowerShell.PSConsoleReadLine]::EndOfLine()&#125;Set-PSReadLineKeyHandler -Key DownArrow -ScriptBlock &#123;    [Microsoft.PowerShell.PSConsoleReadLine]::HistorySearchForward()    [Microsoft.PowerShell.PSConsoleReadLine]::EndOfLine()&#125;


Git  

项目开发必备


vscode  

强大的代码编辑器  
注意：Microsoft发布的Visual Studio Code含有遥测代码




AutoHotKey  

强大的脚本工具



EcoPaste  

跨平台剪贴板管理工具


ShareX  

功能强大的截图工具


weasel  

Rime输入法框架  
雾凇



MPC-BE  

开源播放器（推荐替代PotPlayer）  
配套组件：  
LAVFilters  
xy-VSFilter  
madvr


配置指南：万年冷冻库


MusicPlayer2  

开源音乐播放器



Nanazip  

7zip分支，支持Win11右键菜单，UI现代化


eza  

命令行文件管理工具（替代ls命令）



Watt Toolkit  

Steam工具箱  
反代加速服务


Clash Verge rev  

Clash图形用户界面


Gopeed  

Go语言实现的高性能下载工具



fastfetch  

快捷打印系统信息


thefuck  

命令行神器，自动纠正错误命令



scriptcat

国产开源浏览器脚本管理工具


uBlock Origin

强大的广告拦截工具


cat-catch

网页媒体下载工具


pixiv-toolkit

Pixiv工具箱




记录完]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
        <tag>开源</tag>
      </tags>
  </entry>
</search>
